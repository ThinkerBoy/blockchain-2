//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 - 2020 @chainX.zh

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


## 概述

交易是信用呈现和转移的一个包装单元，除了必要的基本信息外，一笔交易中主要包含输入和输出两个部分。输入表达的是信用来源，由另一笔交易的输出定义。输出表达信用转移的目的地，由信用值（如金额）和一个可执行的锁定脚本构成。谁能提供解锁证明让输出脚本执行成功，谁就是信用值的主人，即有能力在一笔新的交易中把它当作输入使用。

在本设计中，信用的数字表达有三个：**币金**、**凭信** 和 **证据**，它们被称为「信元」。币金信元是可拆分的数值，类似货币；凭信信元是不可拆分的文本或二进制数据，类似契约、债券或与实物绑定的数字凭证；证据信元则是一种存在性表达，可能是文本也可能是二进制数据，不可拆分也不能转移。

如果一笔交易里的输入项全部是币金，这就是一笔纯粹的转账交易，如果还包含有凭信或证据，就是一笔混合交易。仅仅包含凭信或证据的交易没有问题，但交易费是必需的，即需要有币金的输入（注：如果没有币金输出，则全部变为交易费）。

锁定脚本由指令序列构成，包含数据定义、流程控制、算术运算、条件对比、对外交互、以及功能性函数指令等。解锁证明也是一段指令序列，俗称解锁脚本或解锁参数，通常只是数据定义和设置（存储到全局或顶层局域）。脚本的运行沿用Bitcoin中的 **栈结构** 设计，栈内的数据被视为指令的实参，指令执行的结果被压入栈中，成为后续指令的参数。栈是后进先出（LIFO）的逻辑，出于安全和性能的考虑，脚本有长度和执行规模的限制。

不同于Bitcoin系统中对脚本指令的严格约束，这里进行了较多的语言扩展，希望获得比较完整的编程逻辑。这是一个尝试，请以审视的眼光看待！

> **注：**
> 后面文中的代码并非Go语言代码，仅是借用语法颜色获得友好显示。



## 三种基本信元

### 币金

数字化的信用单位，表达具体额度的价值，类似于货币或金钱，有时也被称为代币或Token。因为是数值，所以可以执行算术逻辑，分割或合并。接收币金的通常都是一个标准地址，出于优化，解锁会默认执行前置的签名验证，即验证指令序列无需书写在锁定脚本里。

> **注：**<br>
> 接收者也可以是非标准的任意内容，此时则无法应用标准的验证程序。<br>

币金的生成只能由区块的铸造者完成，但币金的转移交易则是普适的，任何人都可以创建。


#### 接收者

如果是采用系统内置的默认验证，接收者必需是标准的地址格式。否则接收者名称长度不超过256字节（首字节指定实际长度）。

是否采用系统内置验证，由输出的配置字段指定（见后「输出标记」）。


#### 数量

一个变长的整数值，表达币金的数量。基本单位为「聪」。


#### 锁定脚本

控制该笔币金是否能被用户使用（作为新交易的输入）。如果用户提供的解锁脚本使得锁定脚本执行成功通过，则该笔币金就成功使用了出去。


### 凭信

信用凭据的数字化表达，代表某种特定的价值或承诺，可转让或可修订。与币金信元不同，除了接收者外，还有「创建者」、「描述」和「附件ID」几个字段。

凭信转移也被视为 **花费**，与币金一样，未花费的凭信会进入 `UTXO` 集。


#### 接收者

与币金的接收者相同，如果没有设置定制验证标记，会启用默认的内置签名验证，因此接收者就必需是标准的地址格式。


#### 创建者

标记凭信创建交易的区块号和交易ID。创建泛指：初次创建、修订后创建和转为不可修改模式。

与币金只能由区块铸造者生成不同，凭信可以由任何人创建，也可转移给任何人。需要在每一次转移中检查创建者，如果为非修改类转移则保持不变。

> **注：**
> 创建者实际上是可以通过检索区块链回溯的。这里明确为记录条目是一种方便。


#### 描述

前 2+4+4 字节定义配置。之后为凭信描述，通常为可阅读的文本。

```go
// 首2字节配置。
 15] 含有效期。置位此标记，后面的4字节记录字段有效。
 14] 可否修改。置位表示描述和附件ID可修改，转移指令会检查输出项是否合规。
 13] 创生标记。最初创建时的标记。
 12] 次数标记。置位表示需验算转移次数，后面的2字节相应字段有效。
 11] （未用）
 10] 销毁标记。当前凭信转移逻辑终结，不再进入UTXO集。
9-0] 指明描述文本长度，10位最长可表达1kb内容。
// 后8字节设置
[32] 转移次数递减剩余值。可选。
[32] 以秒为单位的有效期时间长度，从交易时间戳开始计算。可选。
```

> **注记：**
> 4字节的转移次数剩余值为从凭信创生开始，但也可能包含内部结构（如标记起点为创生、修订或模式更改等）。

**附件ID**（可选）

如果输出类型字段中附件标记置位，则包含一个长 `32+4` 字节的附件ID：前32字节为附件数据的哈希摘要，后4字节则为附件大小（字节数）。

要求提供附件大小信息，可为某些用途提供便利。这些附件会被存储到archives公共服务网络上。


#### 锁定脚本

控制该凭信是否可以被转移出去。如果用户提供的解锁脚本使得锁定脚本成功执行，则转移成功。

锁定脚本可以只是一个简单的 `NIL` 值，此时表示脚本不可执行，也即凭信不可转移。**注**：与描述字段的销毁标记效果相同。

> **注记：**
> 如果描述字段的销毁标记置位，但此处依然有脚本代码，会被视为 **识别脚本**（同下证据信元逻辑）。


#### 附：凭信的转移验证逻辑

**不可修改凭信：**
> 无输入源：表示新建凭信，创生标记置位，可否修改标记清位。<br>
> 有输入源：表示凭信转移。检查输入源创生标记是否置位，是则为「引用传递」，否则为「复制传递」。<br>

**可修改凭信：**
> 无输入源：表示新建凭信，创生标记置位，可否修改标记置位。<br>
> 有输入源：表示凭信转移。当前保持可修改时，验证为「修订传递」；转为不可修改时，创生标记置位，可否修改标记清位。<br>

**引用传递：**
> 输出为标准格式的源引用：理想块高度 + 交易ID + 输出下标。合计 `4+32+2` 字节。<br>
> 输出项创生标记必须清位（置零）。<br>

**复制传递：**
> 输出与输入源的内容（标准引用）完全一样，不可改变。

**修订传递：**
> 如果内容发生了变化（包括附件变化），创生标记置位。<br>
> 如果内容未改变，创生标记清位。类似不可修改凭信引用传递或复制传递。<br>。

**说明：**
- 可修改凭信可以通过清位修改标记而转变为不可修改凭信，但反过来则不允许。这是设计的限制。
- 由可修订改为不可修订后，创生标记必须置位，同时内容和附件ID也应当是原始内容（非引用）才行，否则可能造成问题。
- 引用/复制传递的设计使得凭信可以追溯到初始创建者，这有时很有用，如「侧链微支付」中的铸造者资格验证。


### 证据

与币金和凭信不同，证据是用来表达存在性的，仅可使用而不可转移。借助于区块链的信用能力和网络本身，它的用途可以有很多，简单的如 **存在性证明**（如版权声明）、**CA证书存储**（供公开检索）、**话题索引**（一条子链就是一个自由的讨论集），**基础凭证**（如选举子链的授权公钥清单）等。复杂一点的或可用于链间数据存储，或是作为第三方应用所需的定制数据。

证据可由任何人创建，不可转移，因此也无需 **创建者** 字段。


#### 名称

证据的标题，类似币金和凭信中的接收者。最长256字节，首字节定义实际长度。


#### 内容

前 2+4 字节定义配置，与凭信不同，有效期不是可选的。

```go
// 首2字节。
  15] 超长标记。置位后表示后续15位用于记录内容长度。
14-8] 自定义区。如果超长标记未设置，此处可自由定义。
 7-0] 内容的长度定义（字节数），可能与前7位合并使用，最大支持到32kb。

// 后4字节。
 [32] 以秒为单位的有效期时间长度，不可选。
```

**附件ID**（同上，可选）


#### 识别脚本

用于证据的程序化识别能力。因为证据不可转移，不能作为新交易的输入项，所以这种脚本只对识别者有意义。



## 输出标记

交易的输出脚本有多种类型，包含各自不同的约束，由1个字节设置标记。

```go
7] 自定义类。声明为第三方扩展，仅对相应的客户端有用。
6] 包含附件。声明是否携带附件。通常仅用于凭信、证据和自定义类。
5] 中介管理。声明为接收前阶脚本跳转的「管理者」脚本。
4] 定制验证。停用系统内置的默认签名验证，完全由脚本自己实施控制。
3] 多重签名。标记接收者为多重签名地址，以便于启动内置的多重签名验证。
2] 证据记录。说明当前输出为证据。在标准的交易中不能作为输入源。
1] 凭信转移。标记为凭信转移。脚本中应当包含 `MOVE` 的通过性验证。
0] 币金转移。标记为币金支付。成功与否由 `PASS` 指令表达。
```


### 自定义类

脚本中包含了第三方扩展指令时，需要进行此标注。扩展指令是私有的，由扩展所属的专用客户端理解和执行。此类输出无法被标准客户端理解，因此不能作为标准交易的输入源。这也是本设计中对第三方扩展的支持方式。

如果一笔输出被标记为自定义类，则该标记字段的低6位就是长度计数，指明后续多少字节是该第三方扩展的标识ID，再后面就是该扩展的私有脚本。第三方客户端依赖此ID来分辨自己的数据，6位支持最长63字节的ID标识。


### 中介管理

对交易输入的验证允许交易间跳转，即从一笔交易跳转到另一笔交易继续工作，这是本系统中一个重要的机制设计。接收跳转的输出就是管理者脚本，需要设置此标记位。这是严格的，它只能接受其它脚本的跳转进入，而不能直接作为交易里的输入源。

这样的设计可以允许外部管理的嵌入，比如先构建一笔监管者交易，用途是接收其它交易的跳转进入，收集传递过来的财务数据（并触发外部行为），这样就可以实现商家主动申报税务的功能。注：数据可以用监管者的公钥加密。

> **注：**<br>
> 中介管理脚本没有签名验证的逻辑，因此没有接收者等额外字段。<br>
> 出于安全和性能的考虑，跳转行为有最大次数限制，目前是不超过4次（通常来说已经足够）。<br>


### 定制验证

系统内置有默认的签名验证流程，只要接收者地址为标准格式，就可以不在脚本中书写验证代码。通常来说，币金交易的接收者都是合法的标准格式地址，因此简单的币金支付实际上都可以省略掉脚本，而定制验证标记清位即可。

对于凭信的转移，因为接收者很可能是自由的个性化定义，所以需要注意该标记位的设置。


### 多重签名

标记当前接收者是否为多重签名地址，告知系统在采用内置验证时该采用哪一种签名验证流程。

#### 附：多重签名地址

多重签名地址的构造：

1. 每个公钥执行一次哈希运算，得到各自的公钥哈希。即：`PKH = Hash( pubkey )`。
2. 全部公钥哈希排序串连，前置2字节的 `n/t` 配比后计算总的哈希。即：`PKHS = Hash( <n/t> + PKH_1 + PKH_2 + ... )`。
3. 在该总的哈希前置2字节 `n/t` 配置，即为多重签名地址。
4. 可将上面的多重签名地址编码为文本形式，并前置专有标识以便于区分。

这里，每一位多重签名的参与者只需要提供自己公钥的哈希（而不是公钥本身），提高了安全性。

> **注：**
> 多重配比 `n/t` 表示总共有 `t` 个公钥，至少需要有 `n` 个签名才有效。

对多重签名验证的解锁实参包含：

1. 提供 `n/t` 配比信息。
2. 至少n个公钥。其中每个公钥前置1字节标明它在公钥列表里的序号（注：这样更高效）。
3. 不参与签名的公钥哈希序列（`t-n` 个），用于与前面已提供的 `n` 个公钥共同构造多重签名地址。
4. 同前n个公钥对交易ID的签名数据，用于验证签名。



## 脚本指令集

从更宽泛的意义上看，脚本应该就是合约，而合约是自由的。本设计中的脚本指令包含完整的执行流语法如：`if`、`else`、`switch`、`case`、`each`，运算操作符如：`+`、`-`、`*`、`/`，数据类型如：`Bool`、`Int`、`Bytes`、`String`、`Float`，以及其它必要的结构。


### 基本概念

#### 数据栈

脚本的执行就是脚本中指令序列的逐个运行，大多数指令都是对数据进行操作，并返回一个或多个值，提供和存储这些数据的地方就是脚本的数据栈。指令通过实参的方式获取栈内的数据，需要多少个实参取决于指令的参数定义。

默认情况下，从栈内取实参是一种 **取出** 的逻辑，即数据会弹出数据栈，而指令的返回值会自动入栈。

准确地说，指令实际上是通过下面的「实参空间」渠道来获取的。

> **注：**
> 数据栈存放通用类型值（`interface{}`），指令需要自己检查实参类型是否正确。


#### 实参空间

栈结构有一种局限：只能从栈顶压入和取出数据。这对于需要充分灵活性的脚本编程来说约束太大，因此这里添加了「实参空间」的逻辑。

实参空间是一个临时的储值栈，如果指令需要实参，系统会首先尝试从实参空间里取值，如果空间内无值，再自动从数据栈里取值。实参空间也是一种栈结构，可以持续压入新的数据，但使用是 **一次性** 取值，即：如果指令需要实参，会一次性取出实参空间全部的值。

指令的返回值会自动进入数据栈，而实参空间保留从数据栈提取出来的值，这就有了一个小循环， 同时也获得了一种腾挪的机制。

实参空间有时也简称为实参区，将数据压入其中是由取值指令（`@`, `&`）来完成的。

指令需要的实参数量是指令的一个基本属性，它决定了系统自动从数据栈进阶取值的数量。如果指令不需要实参就不会从实参区取值，因此实参空间会保持原样。

> **附：实参数量属性**
> - `0`   无需求。不读取实参区，故也不影响当前实参区。
> - `n`   固定数量。如果实参区无值，则自动从数据栈提取 `n` 条数据。**注**：实参区有值但数量不符，会导致出错。
> - `-1`  不定数量。实参空间有值则提取传递，否则忽略。不会自动从数据栈取值。


#### 附属参数

指令操作的数据就是它的实参，但有时指令本身也需要描述，来说明它的某种特性，这些描述就是指令的附属参数（简称「附参」）。

附参紧跟在指令之后，大多数情况下，它们只有1个字节，比如描述if语句块的长度。这是一种基础性设计，可以简化很多事情，同时它也是指令扩展的依靠。

> **注记：**
> 附属参数也是指令的基本属性之一，包含两项内容：`附参数量`，`总占用字节数`。
> 前者用于附参替代时向数据栈说明取栈数量，后者用于指令执行时了解附参占位空间大小。


#### 局部域存储

栈式脚本中并不方便书写变量声明和赋值。

这里我们加入了一个局部域空间的设计，它是有限的，并且只能添加和读取（不能定位赋值）。域也是当前局部的，随着一个语法块的开启和结束而新建和销毁。在脚本的顶层也有一个私有的局部域，没有办法从内层或其它层读取它们。嵌入的子脚本也同样如此。

向局部域添加数据通过特殊符号指令 `&` 完成。


#### 多返回值

指令可以返回一个或多个值，如果是返回多个值，系统会将之自动展开存放（如进入数据栈、实参空间或添加到局部变量域）。

与实参数量要求一样，指令的返回值数量也是指令的一个基本属性。

- `0`  无返回值。系统不会有任何多余行为。
- `1`  单返回值。直接入栈或进入实参空间（`@`）或当前局部域（`&`）。
- `-1` 不定数量。会被系统自动展开压入相应的存储区。数量可为零（被简单忽略）。
- `n`  特定数量。同上会被系统展开存储，可能有数量验证逻辑。


#### 缓存区和监听池

本系统中有包含交互逻辑的指令（如 `INPUT`、`OUTPUT` 等），这样区块链就可以与外部相连系，比如导出数据，由正在监听的中间件处理，完成外部事务。

脚本与外部的交互通过两个各自独立的缓存区实现，一个导出，一个导入。

中间件的监听驱动则是由监听池实施的，逻辑上，这些监听的中间件是私有的：只有需要的节点才需要部署。因此交互指令的执行是非阻塞的，客观效果表现为：导出数据即可，脚本继续后面的逻辑。**注**：导入时则需要后续指令处理。

由于中间件的桥接，外部系统可以是任意的。


### 指令空间规划

每个指令都有一个值，脚本就是指令的值的序列。用数值而不是字符串来表达指令，可以节省空间并让指令的解析和执行更为高效。

指令空间就是这个值的范围，本系统中使用了 `1字节` 的空间（`uint8`）来实现。因为有了指令附参的设计，所以实际上可以通过附参来扩展不限数量的指令。

1. **基础指令段**：包含全部的语法相关的基础指令，如：流程控制、数学运算、栈操作、对外交互和模式匹配等。占位：`[0-159]`，共 **160** 个。
2. **函数指令段**：高频和常用的功能性函数，也包含2个自扩展指令。占位：`[160-199]`，共 **40** 个。
3. **模块指令段**：定义一些基本和标准模块，以及1个自扩展指令。占位：`[200-247]`，共 **48** 个。
4. **扩展指令段**：专用于指令的扩展引用，包括2个基础扩展指令和2个私有扩展指令。占位：`[248-255]`，共 **8** 个。


### 指令命名和书写约定

根据指令的特性（是什么），划分了如下5大类别，其命名遵循简单的规则：

1. 基础功能。指令名无前缀，视觉上简洁明快。如：`PASS` 真值通过。
2. 系统环境。指令名前缀 `SYS_`，如：`SYS_ENV{}` 系统环境取值指令。
3. 函数调用。指令名前缀 `FN_`，如：`FN_CHECKSIG` 签名验证。
4. 模块归类。指令名前缀 `MO_`，如：`MO_MATH{}` 数学模块，`MO_MATH{Abs}` 调用 `math.Abs()`。
5. 扩展定制。指令名前缀 `EX_`，如：`EX_BASE2` 基础扩展引用。

指令的书写显示约定：

- `{}` 花括号用于包围指令关联的数据，比如值指令的实际数据、if语句块的子指令序列等。
- `[]` 中括号用于标示指令附参的值，非必需时可省略。如：`DATA[20]{...}` 表示20字节长的字节序列。**注**：该指令可简写为 `DATA{...}`。
- `()` 除了本身作为表达式/优先级指令外，也用于表达指令附参的长度（字节数）。如 `DATA{}(1)`，表示一个1字节长的附参。多个附参用逗号（`,`）分隔。
- `<>` 尖括号用于表达命名数据，如：`<pubKey>` 指公钥，`<hashSource>` 指哈希源（用于哈希运算的数据）。

该约定也用于解析程序员书写的脚本。因为交易里实际存储的脚本是一个值序列，所以需要先解析。


### 指令的类型

从指令的功能（干什么）上看，有如下类型划分：

1. **值指令**。脚本中的一个实际的值，会自动入栈。如：`FALSE`、`TRUE`、`DATA{}` 等。
2. **取值指令**。截取跟随指令的返回值，将它们置于当前位置（实参空间）或添加到局部变量域，或者引用局部变量域的值。
3. **栈操作指令**。对数据栈中的条目执行简单操作，如：压入、弹出、引用等。
4. **交互指令**。与一个缓存区交互，执行栈数据的导出与导入等。中间件可与该缓存区交互，从而实现外部逻辑。
5. **结果指令**。对执行结果进行通关性裁决，失败会终止脚本。如：`PASS` 通行验证，假值会终止执行流， `GOTO` 则会跳转到另一笔交易。
6. **流程指令**。实现执行流的控制，包含：`IF{}`、`ELSE{}`、`SWITCH{}`、`CASE{}`、`EACH{}`、`BREAK` 等。
7. **转换指令**。对实参值进行类型转换，也包括将分片类型展开（`SPREAD`）为多个值。
8. **运算指令**。包含加减乘除模位移等数值运算，以及小括号的优先级分隔等。
9. **比较指令**。比较2个实参值大小，返回布尔值并自动入栈（除非被取值指令截获）。
10. **逻辑指令**。实现逻辑与（&&）和逻辑或（||）的功能，有的可同时检测多个值，如：`EVERY`、`SOME`、`BOTH` 等。
11. **模式指令**。判断脚本是否符合预期的逻辑（模型），指令包含：`MODEL<>{}`、`#`、`?`、`/../`、`!{}` 等。
12. **环境指令**。提供交易环境相关联的一些数据，如：`IN{}`、`OUT{}`、`VAR` 等。
13. **工具指令**。实现某些实用功能的指令，如：`DIVMOD`、`WITHIN`、`EVAL`、`RANGE` 等。
14. **系统指令**。和系统全局有关的一些指令，比如获取系统全局状态。
15. **函数指令**。一些常用的基础和标准功能函数。
16. **模块指令**。包含一些专项功能的特定模块，其中有它自己的指令集。
17. **扩展指令**。用附参引入扩展的功能指令，仅需几个标识性导入指令即可。


### 示例

#### 通用的币金输出验证

用户构造一笔交易，输入源引用资金来源交易，提供解锁脚本。如果解锁脚本与资金来源交易的输出脚本串接后执行成功，则花费该笔输出成功（即用正确的解锁脚本证明自己拥有所有权）。当前交易的输出即为这笔花费的去向，将由下一位使用者提供其自己的解锁脚本来花费。

```go
// 解锁脚本：
// 由使用者在花费币金时提供。
DATA{<sig>}     // 签名
DATA{<pubKey>}  // 公钥

// 锁定脚本：
// 即源交易的输出脚本，已固化在区块中。
TOP FN_HASH160 DATA{46af3fb481837fadbb421727f9959c2d32a36829} EQUAL PASS FN_CHECKSIG PASS
```

**解释：**

1. `DATA{<sig>}`：签名入栈。
2. `DATA{<pubKey>}`：公钥入栈。
3. `TOP`：引用栈顶返回，自动入栈。注：相当于克隆。
4. `FN_HASH160`：取出栈顶1项计算公钥哈希后入栈。即：`FN_HASH160(<pubKey>)`。
5. `DATA{46af3fb481837fadbb421727f9959c2d32a36829}`：公钥哈希序列直接入栈。注：非公钥本身，实为一层哈希屏障保护。
6. `EQUAL`：取出栈顶2项作相等比较，结果 TRUE 或 FALSE 入栈。
7. `PASS`：取出栈顶值检查是否为 TRUE，是则通过，否则失败。
8. `FN_CHECKSIG`：取出栈顶2项（即 `<sig>` 和 `<pubKey>`），验证签名数据。结果 TRUE 或 FALSE 入栈。
9. `PASS`：取出栈顶1项检查是否为 TRUE，是则通过，否则失败。

> **注：**
> 指令详情请参考后续「脚本基础指令集」部分。

**更多的例子请参考：**

- [链间兑换](examples/链间兑换.md)
- [存在性证明](examples/存在性证明.md)
- [链间授信](examples/链间授信.md)
- [批量付款确认](examples/批量付款确认.md)
- [网购支付流程](examples/网购支付流程.md)
- [实时税务](examples/实时税务.md)
- [版权登记](examples/版权登记.md)
- [侧链微支付](examples/侧链微支付.md)
- [选举子链](examples/选举子链.md)


## 主要特点

### 逻辑完整的执行流指令

在Bitcoin系统的脚本操作指令中，出于性能和安全的考虑，并没有循环类指令如 `OP_LOOP`，这是一种严格约束的设计。但这样的强约束不易于构建需要大量灵活性的合约，因此可扩展性实际上也是Bitcoin的一个短板。

通常意义上的循环可能导致循环死锁攻击，但如果循环本身是有限制的，则不存在这一问题。本设计中使用 `EACH{}` 指令来实现这一有限循环的逻辑，循环是针对有限的数据进行迭代，而数据量及数据本身的大小也是有限的。

流程控制指令包含：

- `IF{}(1)`      检查实参为真值时执行。附参指定了语句块长度，因此endif指令就不需要了。
- `ELSE{}(1)`    if 的否则执行。附参含义同上。
- `SWITCH{}(2)`  分支选择区指令。取实参为后续条件分支的对比目标，2字节的附参指定了语句块的大小。
- `CASE{}(1,1)`  条件分支。两个附参分别指定了条件表达式和分支语句块的长度，前者的结果与switch的目标值比较，相等则执行语句块。
- `DEFAULT{}(1)` 默认分支。所有case都不匹配时执行，通常放在区域最后，附参指定了块长度。
- `EACH{}(1)`    有限迭代循环。附参指定了语句块的长度。
- `BREAK`        退出each循环或switch块。

> **附注：**<br>
> 如果一笔交易的验证需要消耗大量的资源，它可能会成为不受欢迎者而被加入黑名单，这对交易的构造者是一种压力。<br>
> 为避免强铸造者收录高消耗交易而使得其它节点难以确认，系统对一个脚本中each指令的数量可能有限制（比如 <=5次）。<br>
> 本设计中的指令天然附带限制，用户应当尽量扁平化逻辑，避免构建过于复杂的脚本。<br>


### 与链外的数据交互

在本设计中存在交互指令：`INPUT、OUTPUT、BUFDUMP` 等，其中 `INPUT` 和 `OUTPUT` 用于从缓存区导入或向缓存区导出数据，`BUFDUMP` 则实现缓存区数据的清空和对外递送（向预先注册的回调传递数据）。这实现了与外部世界的交互或驱动。

交互行为在脚本执行时发生，需要当前环境里存在相应的需求，如中间件运行或注册了监听，因此这是一个私有应用的范畴。对于导入，中间件需要向缓存区预先存入数据，当脚本执行的时候，数据就进入了脚本的执行流。对于导出，脚本执行前中间件应当已经注册了监听，当脚本执行时，数据导出并驱动中间件的外部行为。

另外，因为是私有的逻辑，如果必要，客户端实际上可以重新执行脚本。


### 脚本执行环境限定

区块链是一个开放的系统，开放的环境就肯定存在故意的攻击。恶意的攻击者可能构建十分消耗资源的交易来拖累系统，因此这里设计了一些基本限制：

- 数据栈高度：`< 256`。栈式脚本在运行过程中，数据栈内的数据大多会被即时使用，所以高度容量并不需要太大。
- 实参区高度：`< 256`。同数据栈限定。
- 缓存区高度：`< 256`。同上。
- 栈数据项大小：`< 1kb`。
- 锁定脚本长度：`< 1kb`。
- 解锁脚本长度：`< 4kb`。
- 单笔交易大小：`< 64kb`（含签名数据）。
- 每区块包含交易数量：`< 64k`。
- 附属参数个数：`<= 7个`。
- 附属参数总长：`< 128b`。这在指令设计时体现。
- GOTO连续跳转次数：`<= 3次`。比如：管理者+审计者+第三方。
- JUMP使用次数：`<= 3次`（实际可达）。
- 迭代循环次数：`< 256次`。即三个集合类指令：`MAP{}`、`FILTER{}` 和 `EACH{}`。
- 区块大小：`< 32mb`。

脚本的指令序列是顺序执行的，不存在回退逻辑（返回到前面的指令），因此一个固定长度的脚本其执行的资源消耗是有限的。

> #### 附：对区块大小限额的思考
>
> 影响区块大小的因素有二：1. 打包交易的数量；2. 每笔交易本身的大小。
> 在本设计中，交易的内涵较为丰富，包含币金/凭信/证据三种信元类型，相较于交易数量，交易本身数据量的变化更大，也更为重要。
> 因此，设计倾向于硬性限制交易的数量，而通过交易本身大小的限制放宽来提高区块容度。
>
> 区块链可能更应该是一种介质而非平台，现实当中应该有很多相互协作的区块链存在，所以包含巨量交易的意义似乎不大。
> 设计预估的每区块交易数量是64k上限（初期为32k），这可能是合理的。


### 第三方扩展

区块链主要是创建和传递信用，功能相对稳定，发展缓慢或许是一种必要的状态。如果第三方应用可以依附于主链实现自身的业务，借助于主链的状态、数据、交互、以及主网本身，可以尝试某种第三方的功能性扩展（甚至与主链用途大相径庭）。

第三方扩展是私有的范畴，主链客户端不理解也无法直接支持它们，其在主链上的交易通常也只能是发布 **证据**。



-------------------------------------------------------------------------------

上一篇：[激励机制](4.激励机制.md)<br>
下一篇：[脚本基础指令集](6.脚本基础指令集.md)<br>
