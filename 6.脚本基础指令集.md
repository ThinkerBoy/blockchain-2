//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 - 2021 @cxio/blockchain

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

## 基础指令集

> **注**：下面的代码并非Go语言代码，仅为显示友好。


### 1. 值指令

在脚本中作为一个实际的值存在，直接自动入栈。

指令的附参指示了数据的具体长度（字节数），如果书写时已经写出了全部数据，则可以省略附参（中括号的部分）。

值区间：`[0-23]`，24个。

```go
指令值  指令名      说明
-----------------------------------------------------------
0       NIL         空值
        // 即Go语言中的 nil 值。
        // 如果一个脚本中只有一个NIL，表示脚本不可执行（失败）。
        // 可视为一个无脚本标识符。

1       TRUE        真值（True）
2       FALSE       假值（False）
        // 类型：Bool，布尔值。
        // 在源码中书写指令名，解析为指令值。
        // 例：
        // TRUE 解析创建的脚本中值为1，运行时自动入栈true。

3       {}(1)       int8，1字节：[-128, 127]
4       {}(1)       byte/uint8，1字节：[0, 255]
5       {}(2)       int16，2字节：[-0x8000, 0x7fff]
6       {}(2)       uint16，2字节：[0, 0xffff]
7       {}(4)       int32/rune，4字节：[-0x80000000, 0x7fffffff]
8       {}(4)       uint32，4字节：[0, 0xffffffff]
9       {}(8)       int64，8字节整数：[-1<<63, 1<<63 - 1]
        // 类型：Int，整数。
        // 附参：指令的关联数据。
        // 从源码解析为指令时，数据值的大小自动决定使用哪个指令。
        // 例：
        // {12756}  入栈正整数，指令选用int16（指令值5）。
        //          脚本中指令序列：首字节值5，后2字节为值 12756
        // {0xfff0} 入栈正整数，指令选用uint16（指令值6）。
        //          脚本中指令序列：首字节值6，后2字节为值 0xfff0（65520）
        // {'\n'}   支持单字节字符表达，解析为 byte 类型。
        //          脚本中指令序列：首字节值4，后1字节值 10（换行符ASCII码值）。
        //
        // 支持千分位的书写方式。
        // 如：{12,345}  实为整数12345。
        //
        // 注记：
        // 有符号整数和无符号整数有一些重叠，通常优先采用有符号整数指令（不要求）。

10      {}(1+n)     大整数，变长字节。
        // 类型：BigInt。
        // 附参：首字节标记实际数据占用的字节数。
        // 注：也即Go语言中 math/big 包里的Int类型。
        // 例：
        // {0x8000ffff 8000ffff 01}
        // 超出了int64的表示范围。通常用16进制书写，允许值内空格友好。

11      {}(4)       浮点数（4字节，float32）
12      {}(8)       浮点数（8字节，float64）
        // 类型：Float，浮点数。
        // 附参：指令的关联数据。
        // 源码书写时必须包含小数点，支持科学记数法。
        // 解析为指令时，值的大小自动决定使用哪个指令。
        // 例：
        // {3.14159} 入栈浮点数 3.14159。指令值为11。
        // {2.1606e108} 超出float32容量。指令值为12。
        // 注记：
        // 系统实现可能会统一转换到float64类型后使用。

13      DATA{}(1)   字节序列数据。1字节附参。
14      DATA{}(2)   字节序列数据。2字节附参。
        // 类型：Bytes，字节序列。
        // 附参：后续实际数据的长度（字节数）。
        // 源码书写时使用16进制字符串，解析时值的长度自动决定指令值（若未指定附参）。
        // DATA{}(2) 指令2字节附参最大可表示64kb数据。
        // 例1：
        // DATA{46af3fb481837fadbb421727f9959c2d} 入栈16字节值，按16进制解析。
        // 解析后的指令序列：
        // [13|16|0x46|0xaf|0x3f|...] 共18字节，首字节指令值，次字节数据长度。
        // 例2:
        // DATA[8]{46af3fb4} 入栈8字节，不足者用0值补充。
        // 解析后的指令序列：
        // [13|8|0x46|0xaf|0x3f|0xb4|0|0|0|0] 共10字节，首字节指令值，次字节数据长度。
        // 注：
        // 花括号内的16进制字符串无需前置 0x 标识。
        // 其它指令的解析类此：首字节指令值，后续为附参（如果有）和关联数据（如果有）。

15      TEXT{}(1)   文本数据。1字节附参。
16      TEXT{}(2)   文本数据。2字节附参。
        // 类型：String，字符串。
        // 附参：后续实际字符串 `UTF-8` 编码字节数。
        // 从源码解析为指令序列时，文本的字节长度自动决定使用哪个指令（15|16）。
        // 例：
        // TEXT{Hello}      入栈 Hello 文本串。
        // TEXT{ "Hello" }  同上，可用引号包围字符串。
        // TEXT[5]{Hai}     明确声明数据长度为5字节，多余字节为0值。
        // 注：
        // 花括号内的字符串无需引号包围，此时括号内前后空白也是数据。
        // 如果需要添加空白友好视觉，可用引号把字符串括起来。
        // 注意：
        // 通常无需明确指定附参值大小，对于宽字节字符来说，这反而容易出问题。

17      /.../(1)    正则表达式。
        // 类型：RegExp。
        // 附参：表达式占用字节数。
        // 双斜线之内为表达式的字符串形式。
        // 注：
        // 运行时会解析为一个正则表达式对象。

18      TIME{}(~)   时间表达式。
        // 类型：Date。
        // 附参：UNIX时间戳。变长正整数。
        // 花括号内书写为标准格式的时间表达式（RFC3339）。
        // 例：
        // TIME{2006-01-02}
        // TIME{2020-11-24T15:04:05+08:00}
        // 注：
        // 解析的UNIX时间戳精确到毫秒。

19-21   （系统保留）

22      CODE{}(1)   代码/指令序列。
        // 类型：Script。
        // 关联数据为一段指令序列。
        // 源码中书写为指令名，解析后是一个指令值及其附参值的字节序列（Bytes）。
        // 附参：序列长度（解析结果字节数）。
        // 例：
        // CODE{
        //      TOP FN_HASH256 DATA{<hashResult>} EQUAL PASS
        // }
        // 入栈一段哈希屏障验证代码。
        // 注：
        // 附参无需书写，将由解析器解析后自动设置。

23      （保留未用）
```


### 2. 取值指令

截取后面一个跟随指令的返回值，让它们不再自动入栈。依指令的不同，截取的值可能放入实参空间（`@`），或者添加到当前的局部域中（`&`）。另外还有一个附参替代指令，它是一个标识，表示后面紧跟的指令的附参从实参获取（指令本身有附参的特性）。最后是从前面存储的局部域中取值的指令（`&{}`）。

这是几个用特殊符号表示的指令，功能也是特定的。作为一种显示方便，符号与后面的跟随指令无需用空格分隔。

值区间：`[24-28]`，5个。

```go
指令值  指令字      说明
-----------------------------------------------------------
24      @           实参创建。
        // 后一个指令的返回值被拦截放入实参空间。
        // 因为实参空间也为栈顶入值/取值的逻辑，所以也可以理解为放入当前位置。
        // 例1：
        //      @PEEKS[0,2] PRINT[16]
        // 获取栈底2个值展开为2个实参，向控制台打印它们的16进制表示。
        // 例2：
        //      @POPS[3] OUTPUT BUFDUMP
        // 弹出栈顶3项数据展开，输出到缓存区并转储（供外部使用）。
        // 注：
        // 如果后面是附参替代指令~（见下），会简单跳过它。

25      ~           附参替代
        // 指示后一个指令的附参将从实参获取。
        // 此时后面指令的附参不再有用，所以实际上这些附参会被移除（没有了）。
        // 这是一种通用的取值渠道切换机制。
        // 注：
        // 大部分附参只有1字节长，最大值255，从实参取值后可突破这个局限。
        // 该指令应当与后面的指令紧邻，空格是可选的。
        // 例：
        // @POPS[3]   弹出栈顶3项到当前位置（实参空间）。
        // @POPS[0]   弹出数据栈全部条目到当前位置。
        // @POPS[]    同上。中括号内的0值可省略，但括号必须保留。
        // {3} @~POPS 取实参值3为弹出数量，弹出值放到当前位置。
        // {3} @POPS  同上。没有中括号表示附参缺失，故省略前置的指令名是可行的。
        // @POPS      自动取栈顶项为实参表示弹出数量，注意与 @POPS[] 的区别。
        // @~POPS     同上，更明确一些。
        //
        // 例外：
        // 不适用表达指令长度的流程类指令，以及附参用于描述关联数据的值指令。
        // 解析器会提示源码中的这种错误，最终的指令值序列（交易脚本）里不会有这种情况。
        // 另外：
        // 考虑安全性原因，暂不支持引用其它指令的扩展类指令（执行未知指令）。

26      &           局域存值。
        // 取后一个指令的返回值添加到当前局部域中。
        // 局部变量域空间有限，最多可添加128个值。
        // 与实参创建指令@相同，如果后面是附参替代指令~，会简单跳过。
        // 例：
        // &TOP       引用栈顶项（复制）添加到当前局部域中。
        // &POPS[3]   弹出栈顶3项自动展开添加到局部域中（同时添加3个）。
        // {3} &~POPS 从实参取弹出数量定义，弹出栈顶3项展开添加到当前局部域。
        // {3} &POPS  同上，中括号缺失表示附参缺失，需从实参取值。
        // &POPS      自动从栈顶取弹出数量定义，然后再弹出指定数量的条目。
        // &~POPS     同上。更明确一些。

27      &{}(1)      局域取值。
        // 按添加时的顺序引用局部域的值。
        // 附参：局部域成员下标，支持负数从末尾算起。
        // 这可视为&的逆指令。与@一样，提取的值进入当前实参区。
        // 例：
        // &[0]   取第1个添加进局部域中的值，放到当前位置（实参区）。
        // &[-1]  取最后一个添加到局部的值放到当前位置。
        // {3} ~& 取实参3为目标位置，取第4个添加进局部域的值（即 &[3]）到当前位置。
        // 注意混淆：
        // ~& @POPS[3]  自动取栈顶值为目标位置，取出局部域中的值，之后再弹出栈顶3个值。
        // ~&POPS[3]    前段同上，后段 POPS[3] 没有意义（取出又原样返回）。
        // ~& POPS[3]   同上，这才是含义准确的写法。
        // &POPS[3]     弹出栈顶3项展开添加到当前局部域（&实为存值指令:26）。
        //
        // 作为补充，可以用&赋值时的名称来取回值，名称用花括号包围。
        // 因为存在名称重复覆盖的问题，这只是一种辅助语法，只适合「就近」使用。
        // 例：
        // &POP   弹出栈顶项添加到当前局部域。
        // &{POP} 从局部域获取上面添加的值。
        // &MO_MATH.Abs   取栈顶值计算绝对值后，添加到当前局部域。
        // &{MO_MATH.Abs} 从局部域中获取上面添加的值。
        // 注：
        // 模块的方法调用表示为用句点连接模块名和方法名。

28      （保留未用）
```


### 3. 栈操作指令

对脚本数据栈中的条目执行直接的操作，如：入栈、弹出、引用、切片、映射等。通常会配合取值指令 `@` 或 `&` 使用。

> **注：**
> 与其它指令不同，栈操作指令如果需要实参，将不经由实参区而直接读取数据栈。

值区间：`[29-43]`，15个。

```go
指令值  指令字      说明
-----------------------------------------------------------
29      NOP         无操作。
        // 实参：不定数量。
        // 返回值：无。
        // 无任何操作，但会读取实参（清空实参区）。
        // 该指令不会失败。
        // 例：
        // @POPS[3] NOP 弹出栈顶3项到当前位置，读取清空实参区。
        // @INPUT[] NOP 读取导入缓存区到当前位置，清空实参区。
        // NOP          无任何行为，执行继续。
        // 注记：
        // 不定数量实参允许0个实参（系统不会自动从数据栈取值）。

30      PUSH        数据入栈。
        // 把前面的实参序列按顺序压入数据栈。
        // 实参：不定数量。
        // 返回值：无。
        // 例：
        //      &[0] &[1] &[3] PUSH
        // 引用前3个局部变量为实参，顺序压入数据栈。
        // 注：
        // 如果实参空间为空，则没有任何结果。


// 下面的指令无需实参，
// 直接提取（弹出）栈顶条目。
31      POP         栈顶项弹出。
        // 返回值：栈顶项。
        // 如果没有前置取值指令，返回值会自动重新入栈。
        // 例：
        // POP  弹出栈顶项又返回入栈，没有意义。
        // @POP 弹出栈顶项到当前位置（进实参区）。
        // &POP 弹出栈顶项添加到当前局部域存储。

32      POPS(1)     栈顶多项弹出。
        // 附参：弹出的条目数。
        // 附参为uint8类型，0值表示弹出全部。
        // 返回值：
        // 弹出的条目集，保持栈内原有底顶序。不定数量。
        // 例：
        // @POPS[4]     弹出栈顶4项展开到当前位置（实参区）。
        // &POPS[4]     弹出栈顶4项展开添加到局部域。
        // @POPS[]      弹出数据栈全部条目到当前位置，中括号为必需。
        // @~POPS       取出栈顶项为弹出数量，弹出栈内全部。
        // @POPS        同上。
        // POPS[4]      弹出栈顶4项又自动入栈，没有意义。

33      SLICE(1)    栈顶切片。
        // 取出栈顶多个条目封装为一个切片。
        // 如果没有前置取值指令，返回值会自动入栈（单值不展开）。
        // 附参：取栈条目数。
        // 返回值：数据切片（单值）。
        // 例：
        // @SLICE[4]  取出栈顶4项打包为一个切片到当前位置。
        // SLICE[4]   同上封装为切片，返回的切片入栈。
        // &SLICE[4]  同上封装为切片，作为单值添加到当前局部域。
        // 注：
        // 这实际上是一个数据封装指令，变多值为集合单值。
        // 连续的取值可以将栈内数据分别封装为多个集合组，
        // 如：
        //      @SLICE[3] @SLICE[2] PUSH
        // 将栈顶5项打包为两个分片，注意先打包的3项最后先入栈。

34      SPREAD      切片展开。
        // 取出栈顶项展开返回。
        // 如果前置取值指令，会展开压入实参空间或局部域。
        // 返回值：展开的条目，不定数量。
        // 例：
        // &SPREAD  取栈顶项展开压入当前局部域。
        // @SPREAD  取栈顶项展开到当前位置（实参区）。
        // SPREAD   将栈顶项展开后返回入栈。
        // 注：
        // 栈顶项需要为可展开类型，比如一个切片条目。
        // 连续的取值可以将栈内多个切片逐一展开到目标空间。

35      LOPS(1)     移除栈顶多项。
        // 附参：移除的条目数。
        // 附参为uint8类型，0值表示移除全部（清空数据栈）。
        // 返回值：无。
        // 例：
        // LOPS[3]  移除栈顶3项（废除）。
        // LOPS     移除数量由当前实参（取栈顶项）决定。
        // LOPS[]   移除栈内全部数据。
        // @POPS[] NOP  同上。
        // 注：
        // 用于移除栈顶多余的数据以方便后续处理，
        // 可视作是 POPS 和 NOP 复合指令的简捷版。


// 下两个指令为集合处理器，属于函数容器类指令：
// - 子语句块实际上是一个子函数。
// - 包含一个局部共享的私有数据栈结构，实参用于初始化私有数据栈。
// - 操作目标为栈顶（而非实参区）的可迭代对象。
36      MAP{}(1)    集合映射。
        // 迭代每一个成员执行子语句块，返回值构造为一个集合返回。
        // 操作目标为栈顶项，需为一个切片或可迭代集合。
        // 附参：子语句块长度。
        // 实参：不定数量，任意类型。
        // 语法：
        // 子语句块拥有一个局部私有的数据栈，与脚本的全局数据栈无关。
        // 不定数量的实参序列作为私有数据栈的初始导入条目。
        // 私有数据栈在各个迭代之间是共享的，因此这是一个微型公共空间。
        // 局部域变量：
        // - &[0]  // 当前条目数据 &{Value}
        // - &[1]  // 当前循环下标，从0开始 &{Index}
        // - &[2]  // 迭代集本身 &{Origin}
        // 注：
        // 当前局部域中前3个位置被占用并可由指令更新（对用户只读）。
        // 限制：
        // 迭代循环次数小于256（len(data) < 256）。
        // 例：
        // RANGE[10,3]      // 创建了一个切片[10,11,12]入栈
        // {200} {300}      // 简单入栈2个值
        // @POPS[2]         // 弹出为实参，将进入MAP的私有数据栈
        // MAP{             // 将迭代前面创建的切片
        //      &{Index} @POP PRINT
        //      &{Index} &{Value} PRINT
        //      @( &[0] * 2 ) RETURN
        // }
        // 将打印共3组值：
        // - 0 300      // 第1次
        // - 0 10
        // - 1 200      // 第2次
        // - 1 11
        // - 2 NIL      // 第3次，栈内已无值
        // - 2 12
        // 返回的结果集：[20, 22, 24] 自动进入上层数据栈。

37      FILTER{}(1) 集合过滤。
        // 迭代每一个成员执行子语句块，提取返回真值的源成员。
        // 操作目标为栈顶项，需为可迭代对象。
        // 附参：子语句块长度。
        // 实参：不定数量，任意类型。
        // 语法：同上MAP。
        // 局部域变量：同上MAP。
        // 限制：同上，迭代循环次数小于256。
        // 例：
        // RANGE[10,4]      // 创建：[10,11,12,13]
        // FILTER{
        //      ( &[0] % 2 )    // 注：&[0] 没有简写形式（&0）
        //      @BOOL RETURN
        // }
        // 返回的结果：奇数集 [11, 13] 自动进入上层数据栈。
        // 注：
        // 依然可以前置取值指令截取返回值：@FILTER{...}


// 以下为引用方式，不取出栈条目。
// 如果无前置取值指令，返回值自动入栈类似于克隆。
38      TOP         引用栈顶项。
        // 返回值：栈顶项。
        // 例：
        // @TOP 引用栈顶项到当前位置。
        // TOP  引用栈顶项并返回之，自动入栈。注：同 DUP[2]
        // &TOP 引用栈顶项存入当前局部域。

39      TOPS(1)     引用栈顶端多个条目。
        // 附参：引用条目数，0值无意义。
        // 附参uint8类型，受限于255数量。
        // 如果无前置取值指令，相当于多值克隆。
        // 返回值：栈顶多项，不定数量。
        // 例：
        // TOPS[1] 与 TOP 效果相同。
        // TOPS[3] 引用栈顶3项返回。相当于克隆栈顶3项，保持原顺序。
        // TOPS    取出栈顶项作为数量，据此引用之后的栈顶各条目。
        // TOPS[]  无引用返回空，无意义。

40      PEEK(1)     引用栈内任意位置条目。
        // 附参：目标条目下标。
        // 附参int8类型，栈底为0，支持负数从栈顶算起。
        // 返回值：引用目标项。
        // 例：
        // PEEK[-1] 与 TOP 相同。
        // PEEK[0]  引用栈底项（效果：克隆栈底项放到栈顶）。
        // @PEEK[]  同上引用，放入当前位置。
        // &PEEK[]  同上引用，放入当前局部域。

41      PEEKS(1,1)  引用栈内任意位置段条目。
        // 附参1：起始位置下标。
        // int8类型，栈底为0，支持负值从栈顶算起。
        // 附参2：引用条目数。
        // uint8类型，最多引用255条。0值表示目标位置之后全部。
        // 返回值：目标位置段条目，不定数量。
        // 例：
        // @PEEKS[0, 5]  引用栈底5项数据到当前位置。
        // @PEEKS[-5, 0] 引用栈顶5项到当前位置，同：@TOPS[5]
        // PEEKS[0, 5]   引用栈底5项，效果为克隆栈底5项到栈顶。
        // PEEKS         取出栈顶2项为附参替代，据此引用。
        // PEEKS[0, 0]   没有实际意义。
        // PEEKS[]       合法，但同上没有意义。
        // 例：
        //      PEEKS[0,5] SLICE[5]
        // 效果：打包栈底5项为一个切片放到栈顶（单项）。
        //
        //      @PEEKS[0,5] SLICE[5]
        // 注意：与上不同，此为连续取值。
        // 1. 引用栈底5项到当前位置（展开）。
        // 2. 打包栈顶5项为一个切片到当前位置（单值）。

42-43   （保留未用）
```


### 4. 交互指令

在脚本的执行环境中存在一个数据的「缓存区」结构，是与外部发生联系的一个中间区域。对缓存区的读取和写入是非阻塞的，不影响脚本后续执行。

缓存区为先进先出的队列结构，读取即为移出。导入和导出是两个各自独立的缓存区，两者无法直接互通。

值区间：`[44-49]`，6个。

```go
指令值  指令字      说明
-----------------------------------------------------------
44      INPUT(1)    导入缓存区数据。
        // 附参：读取的条目数，0值表示全部。
        // 实参：无。
        // 返回值：不定数量的数据条目。
        // 指令为多值返回，所以会自动展开进入目标空间。
        // 例：
        // @INPUT[0]    导入缓存区全部数据展开到当前位置。
        // &INPUT[3]    导入缓存区头部3项数据展开添加到当前局部域。
        // INPUT[3]     导入缓存取头部3项数据返回（自动展开入栈）。
        // @~INPUT      取栈顶项定义读取数量，读取到当前位置。
        // @INPUT       同上。
        // @INPUT[] NOP 导入缓存区全部数据到当前位置，读取清空。

45      OUTPUT      导出实参区数据到缓存区。
        // 实参：任意，不定数量。
        // 例：
        // @POPS[] OUTPUT  弹出数据栈全部数据并导出到缓存区。
        // OUTPUT  实参区为空，无任何实际结果。

46-47   （系统保留）

48      BUFDUMP     导出缓存区数据转储。
        // 将导出缓存区内容转储到外部，缓存区清空。
        // 通常来说，应当有一个第三方服务存在，用于接收转储的数据。
        // 说明：
        // 由第三方服务提供中间件注册和调用服务。
        // 有无第三方服务是一种私有逻辑，只有需要相关业务的节点才需要运行。
        // 注记：
        // 转储时可能包含一些当前脚本执行的状态。无实参逻辑。

49      PRINT(1)    控制台打印。
        // 多个实参条目用换行分隔。
        // 附参：标记打印的字符串格式。
        //      0   智能格式，默认
        //      2   二进制
        //      8   八进制
        //      10  十进制
        //      16  十六进制
        //      ... 其它标记
        // 实参：任意，不定数量。
        // 例：
        // @POP PRINT[0]  弹出栈顶项并用智能格式打印。
        // @TOPS[3] PRINT[16]  打印栈顶3项数据的十六进制表示。
```


### 5. 结果指令

对脚本的执行实施检查和控制，如：通过、失败、退出或跳转等。

除非脚本就只有一个 `NIL` 值，否则脚本执行中如果没有碰上失败，就视为验证通过。

值区间：`[50-57]`，8个。

```go
指令值  指令字      说明
----------------------------------------------------------
50      PASS        检查通过（安检）。
        // 实参值为TRUE时为通过，否则为失败。
        // 通过失败会导致脚本非通过结束，信用转移失败，脚本终止。
        // 实参：布尔值，单个。
        // 参考：
        // 通关失败应当触发一个通知机制（如BUFDUMP），以便外部可以了解情况。

51      FAIL        验证失败。
        // 实参值为TRUE时失败。
        // 这是 NOT PASS 的简捷版，但表意更清晰。
        // 实参：布尔值，单个。

52      GOTO(4,32,2) 执行流跳转（独立）。
        // 跳转到某个区块的某笔交易的某个序号的输出脚本。
        // - 实参数据（如果有）被传递到新的脚本作为解锁参数使用。
        // - 新脚本继承当前的校验域，但有其自身的脚本域（数据栈、全局空间、缓存区）。
        // - 新脚本的执行结果即为当前脚本的结果（PASS状态）。
        // 附参1：区块高度（理想块），uint32类型
        // 附参2：交易ID，32字节哈希字节序列
        // 附参3：输出项索引，uint16类型。
        // 实参：任意，不定数量。
        // 例：
        //      @TOPS[10] GOTO[1000, 0xcca750..., 1]
        // 引用栈顶10项数据，跳转到第1000号理想块的目标交易的第2项输出，传递实参并继续执行。
        // 注：实参也可能是一个 CODE 的指令值序列。
        //
        // 安全性：
        // 考虑安全性和运行性能，系统的实现中连续跳转应当不超过一定次数。

53      JUMP(4,32,2) 执行流跳转（同域嵌入）。
        // 跳转定位与GOTO指令相同。
        // 目标脚本为嵌入逻辑，共享当前脚本环境（数据栈、全局空间、缓存区）。
        // 子脚本有自己的顶层局部域。
        // 嵌入的子脚本中不再支持嵌入。即：管理者交易中不能使用本指令。
        // 实参：无。
        // 例：
        //     JUMP FN_HASH256 DATA{...} EQUAL PASS
        // 附参替代取栈顶3项为目标定位跳转。
        // 返回后取栈顶值计算哈希摘要（FN_HASH256）和后面的工作。
        // 注：目标子脚本可能往当前栈中添加了哈希源数据。
        //
        // 安全性：
        // 使用附参替代可能会允许任意的嵌入代码。
        // 与GOTO类似，脚本中允许使用的JUMP指令应当有一个限度。

54-55   （系统保留）

56      EXIT        脚本结束。
        // 结束脚本的执行。至此无错视为通过。
        // 如果实参区有值，返回该值（系统可能接收该值）。
        // 实参：任意类型，可选。
        // 返回值：即实参值。

57      RETURN      返回一个值。
        // 从函数式语句块内退出并返回一个值。
        // 函数式语句块指：MAP{} 和 FILTER{} 两个指令的子语句块。
        // 实参：任意类型，可选。
        // 返回值：即实参值。
        // 没有实参值时，只是简单的退出当前函数块。
        // 例：
        // MAP{ // 相对独立的子环境，私有数据栈
        //      ...
        //      @POP RETURN
        // }
        // 子语句块每次迭代的返回值构成一个集合，作为MAP的返回值。
```


### 6. 流程指令

不像普通编程语言中可以用花括号限定语句块的范围，本设计中使用限定性的长度标定方式：表达式或语句块的长度由附参确定。附参的字节数限定了语句块的长度，这是一种严格限制性的设计。因为长度值的使用，结束指令就不再需要了。

语句块的最终长度由解析器解析计算而来，书写时无需包含中括号的附参明示。指令的子语句块即为该指令的关联数据。

> **注：**
> 因为顶层语句块的长度有限，所以实际上代码的嵌套层级也会受限。这可能是有益的。

值区间：`[58-65]`，8个。

```go
指令值  指令字      说明
-----------------------------------------------------------
58      IF{}(1)     真值执行。
        // 实参值为TRUE时执行子语句块。设置IF状态域。
        // 附参：子语句块长度，uint8类型。
        // 实参：布尔值，单值。
        // IF状态域：赋值为实参值的逻辑反，由ELSE使用。
        // 例：
        // ... EQUAL                // 比较结果入栈。
        // IF{                      // 取出栈顶值，为TRUE则执行子语句块
        //      TEXT{Hello!} PRINT  // 打印 Hello!
        // }
        // 条件值在IF指令之前就计算好了，此仅简单比较即可。
        // 状态域存值是为了后面可能有的ELSE语句自我判断。
        // 参考：
        // IF和ELSE之间可能可以允许其它语句，只要是平级的，后来的IF会覆盖之前的IF存值。

59      ELSE{}(1)   IF不满足时执行。
        // 检查IF状态域，如果为真则执行。
        // 附参：指令块长度，uint8类型。
        // 实参：无。
        // IF状态域：如果执行则覆盖赋值为FALSE。
        // 注：
        // IF状态域覆盖赋值之后，后面的ELSE就会无用（也是错误的）。
        // 应当与IF指令配对使用。

60      SWITCH{}(2) 分支选择区。
        // 选择区开启。设置SWITCH状态域。
        // 附参：区域长度，uint16类型。
        // 实参：任意值，单值。
        // SWITCH状态域：赋值为实参值，由后面的CASE使用。
        // 提示：
        // 若标的值为TRUE，可模拟if/elseif/else的逻辑。

61      CASE{}(1)   条件分支。
        // 取实参值与SWITCH状态域的值比较：
        // 真：执行子语句块。
        // 假：跳过子语句块，继续后续平级语句块。
        // 附参：语句块长度。
        // 实参：任意类型，单值。
        // CASE块执行之后即退出SWITCH结构。也可主动退出（BREAK）。
        // 例1：
        // @POP                     // 将被放入SWITCH状态域
        // SWITCH{
        //      @POP + @{99}        // CASE条件先计算。此处结果入栈
        //      CASE{               // 取栈顶值与SWITCH状态域的值比较，相等则执行子语句块
        //          {1000}          // 将值 1000 入栈
        //          BREAK           // 退出SWITCH，可选（会自然退出）
        //      }
        //      {100} @EQUAL        // 下一个CASE的条件。此处结果当前保持
        //      CASE{               // 取实参值与...比较...
        //          ENV{FromHeight}
        //      }
        //      DEFAULT{...}        // 默认分支，抵达则无条件执行
        // }
        // 注记：
        // CASE指令的条件段与指令本身处于平级，这样让条件计算更灵活。
        // 已经执行的CASE子块会直接退出SWITCH结构，因此不会带来多余的计算。

62      DEFAULT{}(1) 默认分支。
        // 无条件执行。
        // 附参：语句块长度。
        // 说明：
        // 其它CASE分支未执行时执行，只能在所有CASE之后。可选。

63      EACH{}(1)   迭代循环。
        // 对实参序列成员逐一迭代处理。
        // 附参：循环块长度。
        // 实参：任意类型，不定数量。
        // 局部域变量：
        // - &[0]  // 当前条目数据 &{Value}
        // - &[1]  // 当前循环下标，从0开始 &{Index}
        // - &[2]  // 迭代条目总数 &{Total}
        // 循环次数：
        // 由实参序列的长度决定（可能额外设限）。
        //
        // 注记：
        // 实参的含义与集合类指令MAP/FILTER有所区别，
        // 这里会直接处理全局数据栈，因此设计为处理实参序列（逻辑上协调）。
        // 另外也继承了实参区的灵活性。

64      BREAK       退出EACH或SWITCH结构。
        // 实参：布尔值，可选。
        // 如果实参有值，则真值执行，假值略过。否则直接执行。
        // 自带判断逻辑，可用于简单的if判断（无需IF{}结构）。
        // 例：
        // @POPS[10]              // 取栈顶10项待处理
        // EACH{
        //      &{Value} @{1000}  // 当前值和目标值
        //      GT                // 当前值大于目标值比较结果入栈
        //      @POP BREAK        // 取比较结果，真值退出 EACH{} 块，假值忽略
        // }
        // 参考：
        // 本指令可能用panic来实现（上层捕获）。

65      （保留未用）
```


### 7. 转换指令

脚本中的值是一种准严格类型，大部分需要显式的类型转换。如果转换之后的类型无法涵盖原值范围，会抛出错误（失败）以避免潜在的安全性问题。

值区间：`[66-77]`，12个。

```go
指令值  指令字      说明
-----------------------------------------------------------
66      BOOL        转换为布尔值：Bool(x)
        // 实参：
        // - 字符串：""  => FALSE; 非空串 => TRUE
        // - 整数：  0   => FALSE; 非零值 => TRUE
        // - 浮点数：0.0 => FALSE; 非零值 => TRUE

67      INT         转换为整数：Int(x)
        // 实参：
        // - 布尔值：TRUE => 1, FALSE => 0
        // - 字符串：任意合法的整数字符串表示，支持千分位（,）分隔符。
        // - 浮点数：截断小数部分，超过int64上限的大数会出错。

68      BIGINT      转换为大整数：BigInt(x)
        // 实参：
        // - 字符串：任意合法的整数字符串表示。
        // - 字节序列：按 Golang math/big 包要求。
        // - 布尔值：TRUE => 1, FALSE => 0
        // - 整数：简单转换（无要求）。
        // - 浮点数：截断小数部分。

69      FLOAT       转换为浮点数：Float(x)
        // 实参：
        // - 布尔值：TRUE => 1.0; FALSE => 0.0
        // - 整数：  简单的类型转换（无要求）
        // - 字符串：合法的浮点数或科学记数法表示。

70      STRING      转换为字符串：String(x)
        // 实参：
        // - 布尔值：TRUE => "True"; FALSE => "False"
        // - 整数：  显示为十进制字符串。
        // - 序列：  视为UTF-8编码的字节序列。
        // - 浮点数：显示为带小数点数字或科学记数法表示。

71      BYTES       转换为序列：Bytes(x)
        // 实参：
        // - 字符串：转换为字符串的UTF-8码值序列。

72      SCRIPT      转换为脚本类型。
        // 实际上依然是一个字节序列，可由EVAL执行。
        // 实参：
        // - 字节序列（Bytes）。

73      REGEXP      转换为一个正则表达式。
        // 用实参值创建一个正则表达式对象。
        // 实参：
        // - 字符串：正则表达式的字符串形式。

74      DATE        转换为日期类型。
        // 用实参构造日期/时间对象。
        // 实参：
        // - 字符串：标准的时间格式串（RFC3339）。
        // - 整数：UNIX时间戳（毫秒数）。
        // 例：
        //      {1608883593536} DATE
        // 用整数值构造一个时间对象（2020-12-25T08:06:33.536Z）。
        //      TEXT{2020-12-25T08:06:33.536Z} DATE
        // 用字符串构造一个时间对象。

75-77   （保留未用）
```


### 8. 运算指令

有两种形式的运算指令：
1. 符号指令。操作数在符号两侧的常见形式，如：`{100} + {10}`。仅用于表达式内，由表达式指令包含。
2. 命名指令。普通指令，操作数作为实参在指令之前，如：`{100} {10} ADD`。适用表达式之外的逐项执行逻辑（结果自动入栈）。

值区间：`[78-101]`，24个。


#### 表达式

表达式是一个完整的运算单元，在表达式中使用的操作数只能是值指令和单纯取值类的指令（如 `{123}、POP、PEEK、ENV{n}、VAR[x]、&[n]` 等），无法包含需要从实参空间取实参的功能性指令，因为没有办法知道当前实参是用于前面的符号指令还是后面的命名指令。

这是一种**严格受限的表达式**逻辑，如果表达式中需要命名指令的值，可以提前执行指令让结果入栈，然后在表达式中简单引用或取值。

表达式是一个独立的小环境，最终的计算结果作为表达式指令的结果返回而自动入栈，但内部的指令的返回值则没有自动入栈的逻辑。


#### 指令清单

```go
指令值  指令字      说明
-----------------------------------------------------------
78      ()(1)       表达式封装（根）。
        // 内部可以包含子表达式，由优先级分组指令（见下）封装。
        // 内部的计算独立于实参空间，因此取值无需@指令（但&取值可用）。
        // 附参：表达式长度。
        // 实参：无。
        // 返回值：任意类型，单值。
        // 例：
        //      ( PEEK[0] + {100} )
        // 栈底值加100，返回值自动入栈。
        // 例：
        //      ( {1.5} * (POP + {100}) )
        // 包含子表达式的复合表达式：取出栈顶值加100后再乘以1.5。
        // 最后的结果（顶层复合表达式）会自动入栈，为一浮点数。
        // 注记：
        // 此时单纯的栈操作指令（如POP）就有了意义。
        // 
        // 提示：
        // 因为顶层的根表达式的返回值与其它普通指令一样会自动入栈，
        // 因此它前面也同样可以使用取值指令拦截结果。
        // 如：
        // @( PEEK[0] + {100} )  将运算结果放入实参区
        // $( ... )  将运算结果添加到局部变量域

79      ()(1)       优先级分组&子表达式。
        // 仅存在于根表达式之内，即：( ...() ) 括号内部的括号部分。
        // 附参：子表达式长度。
        // 实参：无。
        // 返回值：任意类型，由根表达式内部处理。
        //
        // 提示：
        // 子表达式已处于独立环境，无法设置外部的实参区或局部域，
        // 因此不可前置取值指令设置值，但内部指令的实参读取是正常的。
        // 如：
        // ( {1.5} * @(POP + {100}) )  错误。无法设置实参区
        // ( PEEK[0] + &{100} )  错误。无法添加局部变量，且 &{100} 也无返回值
        // ( PEEK[0] + &[0] )    正常，&[0] 为取值而非赋值


// 符号指令（双操作数）
// 注：仅用于表达式内部。
80      *           乘
81      +           加
82      -           减/负
83      %           模（正负号跟随左操作数，同Golang）
84      /           除

85      <<          左移位
86      >>          右移位
87      &           位与：AND
88      |           位或：OR
89      ^           位异或（XOR）
        // 实参在指令前后两侧，遵循普通的运算符优先级。
        // 例：
        // ( {100} + PEEK[0] * {1.5} / {2} )
        // 注：运算符之间的空格是可选的。


// 命名指令（双操作数）
// 注：无法用于表达式内部。
90      MUL         乘：MUL(x, y) => x*y
91      ADD         加：ADD(x, y) => x+y
92      SUB         减：SUB(x, y) => x-y
93      MOD         模：MOD(x, y) => x%y
94      DIV         除：DIV(x, y) => x/y
        // 实参：有序的两个操作数。
        // 返回值：相关类型，单值。
        // 例：
        // {32} {100} MUL  入栈32和100，取栈顶2项相乘
        // @POP @{100} MUL 先取出到实参区后计算。
        // 另：
        // @POP {100} MUL  错误。实参区实际上只有1个值（@POP）。

95      DIVMOD      除并求余。
        // 返回值：商和余数，2个值。
        // 运算式：(n, m) => n % m


// 命名指令（单操作数）
// 注：无法用于表达式内部。
96      NEG         取负：-x  // Int, Float
97      NOT         取反：!v  // Bool
        // 实参：目标操作数。
        // 例：
        // @PEEK[0] NEG   取栈底项置负后返回
        // {123} BOOL NOT 结果为False

98      DUP(1)      复制
        // 同一数据可复制多次。
        // 附参：复制次数。uint8类型，0值没有意义。
        // 返回值：复制的条目，不定数量。
        // 例：
        // DUP[1]       取出栈顶项复制1个返回（实际上没做啥）。
        // DUP[2]       取出栈顶项复制为2个返回。效果同 TOP。
        // DUP[0]       没有复制，返回为空。相当于：LOPS[1]
        // &[0] DUP[1]  引用首个局部成员，复制返回。同：&[0] PUSH
        // ~DUP         附参替代取栈顶项为复制数量，复制之后的栈顶值。
        // DUP          同上。
        // 注：
        // 适用任意数据类型，但主要用于Bytes和String。

99-101  （保留未用）
```

**注意：**
> `ADD, +` 指令对于字符串（`String`）和序列（`Bytes`）是连接操作。


### 9. 比较指令

两个或多个操作数，返回一个布尔值（单值）。

值区间：`[102-109]`，8个。

```go
指令值  指令字      说明
-----------------------------------------------------------
102     EQUAL       相等（a == b）
103     NEQUAL      不相等（a != b）
104     LT          小于（a < b）
105     LTE         小于等于（a <= b）
106     GT          大于（a > b）
107     GTE         大于等于（a >= b）
        // 实参：两个操作数。
        // 运算式：(a, b) => a op b

108     WITHIN(1,1) 范围判断。
        // 附参1：最小值（包含）。
        // 附参2：最大值（包含）。
        // 实参：1个待比较值。
        // 例：
        // ENV{RealHeight} WITHIN[0, 239]
        // 取当前交易所在真实区块高度，检查是否为第一天收录。
        // 注：
        // 本指令和下面的同名指令是对小整数的一个友好支持。
        // 如果需要更大的值范围，可使用附参替代技术。
        // 参考：
        // 实现可能适用任意类型的值范围判断（如果可比较）。

109     WITHIN(2,2) 范围判断。
        // 同上，附参取值稍大。
        // 例：
        // WITHIN[256, 0xffff]     栈顶值是否为必须2个字节表示的值。
        // {256} {0xffff} WITHIN   同上，但由实参定义范围。
        // {256} {0xffff} ~WITHIN  同上，更明确的写法。
        // 注记：
        // 系统会因附参替代指令而先取出需要的数据，之后才是实参取值。
        // 如果实参空间有值，提取替代附参时同样是一次性的逻辑。
        // 因此：
        // @{256} @{0xffff} WITHIN            正确。一次性取出2个附参。
        // &[0] @{256} @{0xffff} WITHIN       错误。取出的附参数量不对。
        // &[0] PUSH @{256} @{0xffff} WITHIN  正确。待比较值 &[0] 已入栈。
        // 注：
        // 解析器取WITHIN指令的值可能是前一个（108），这没有区别。
```

**说明：**
> 序列（`Bytes`）类型的大小比较按从左到右的逐字节进行。
> 布尔（`Bool`） 类型仅适用 `EQUAL, NEQUAL` 比较。


### 10. 逻辑指令

实参需为布尔（`Bool`）类型，返回值为布尔值（`TRUE` 或 `FALSE`）。

值区间：`[110-113]`，4个。

```go
指令值  指令字      说明
-----------------------------------------------------------
110     BOTH        两个都为真（&&）
        // 逻辑AND，是否两个值都为TRUE。
        // 实参：2个Bool值。
        // 例：
        // BOTH PASS  取栈顶两个值，都为TRUE时通过。

111     EVERY       全部为真（类 &&）
        // 逻辑AND，全部实参都为TRUE时为真。
        // 实参：不定数量Bool类型值。
        // 例：
        // @TOPS[3] EVERY  引用栈顶3个值，检查是否都为TRUE。
        // @POPS[2] &[0] EVERY  提取栈顶2项，和首个局部域的值，检查是否都为TRUE。
        // EVERY  实参区无值，返回TRUE。

112     EITHER      两个中任一为真（||）
        // 逻辑OR，两个中是否有其一为TRUE。
        // 实参：2个Bool值。
        // 例：
        // EITHER PASS 提取栈顶两个值，任一为真即通过。

113     SOME(1)     一部分为真（||, &&）
        // 逻辑OR，全部中特定数量的值为TRUE。
        // 附参：为真的最低数量。
        // 实参：不定数量Bool类型值。
        // 如：
        // - SOME[2]  2个以上为真（含2个）
        // - SOME[1]  至少1个为真，较常用
        // - SOME[0]  无条件放行。无意义，类似：NOP
        // 例：
        //      @POPS[3] &[0] SOME[2]
        // 提取栈顶3项和局部域值，检查是否至少有2个为TRUE。
        //      @POPS[3] SOME[0]
        // 弹出栈顶3项，检查并无条件通过：实参必须为Bool类型。
        // 例：
        // SOME[0]  实参区无值，返回TRUE
        // SOME[1]  实参区无值，返回FALSE
```


### 11. 模式指令

指令序列的模式匹配，用于验证目标脚本是否符合特定的逻辑序列。在排除掉可忽略的指令后，目标指令序列需与模式序列完整匹配。如果匹配失败，系统会以 `FAIL` 的方式处理。

一个模式序列通常称为一个模型。一个拥有广泛共识的模型可能会被发布在一笔管理者交易中供任意分享（作为 `GOTO` 目标）。

模式匹配很有用处：比如在链间兑换时确认对方的预支付脚本是否有效、在选举子链中对投票内容的格式做验证（以免选票无效）、甚至由中间件执行匹配并提取信息来执行链外的业务，实现无人工审核的自动化流程。

总的来说，模式匹配的目的是让某件事在 **下一步行动前** 得到确认。

值区间：`[114-125]`，12个。

```go
指令值  指令字          说明
-----------------------------------------------------------
114     MODEL<>{}(1,2)  创建模式匹配区。
        // 开启一个解析子环境，等待对实参字节序列执行模式匹配。
        // 附参1：可忽略指令清单长度，<>内为逗号分隔的指令列表。
        // 附参2：模式区长度，{}内包含了模式匹配序列。
        // 实参： 待测试的指令序列（Bytes），不定数量。
        // 如果实参区有多个值，会被自动合并为一个字节序列。
        // 注：因为属于不定数量实参，所以不会自动从数据栈获取目标。
        // 返回值：#指令收集的值，不定数量。
        // 注意：
        // - 可忽略指令清单长度指占用的字节数，而非指令的个数。
        // - 不方便用名称表达的可忽略指令（如值指令），可用指令值表示。
        // - 忽略是指整个指令，包含附参、关联数据和（如果需要）读取的实参区。
        // - 可忽略指令也可出现在模式区内，此时视为普通指令处理。
        // 例：
        // 支付脚本：
        //      TOP FN_HASH160 DATA{<pkhash>}
        //      @TOP PRINT                  // 将被忽略。与实参取值应紧邻
        //      EQUAL PASS FN_CHECKSIG PASS
        // 模型：
        //      @CODE{ ... }                        // 封装上面的脚本
        //      MODEL<PRINT, INPUT, OUTPUT>
        //      {
        //          TOP FN_HASH160 DATA[20]{?}      // 关联数据长度固定，内容任意
        //          #[4]                            // 取关联数据
        //          EQUAL PASS FN_CHECKSIG PASS     // 严格匹配（原样）
        //      }
        //      @POP OUTPUT BUFDUMP     // 模型之外，正常代码
        // 说明：
        // - #[4] 指令提取了匹配目标的关联数据（公钥哈希）。
        // - 打印指令连同其 @TOP 实参取值被忽略，因此模式中看不到它们。
        // - 模式匹配结束后，MODEL指令返回了提取的公钥哈希。
        // 注：
        // 如果一个未知脚本匹配上面的模型，就说明它的支付逻辑正常。


// 以下为局部指令，仅在MODEL{}之内有效。
115     #(1)        取值指示。
        // 针对前一个指令匹配的目标，取目标的不同部分的值。
        // 附参：取值标识。
        // 0001 - 指令本身。(1)
        // 0010 - 附参部分。(2)
        // 0100 - 关联数据。(4)
        // 1000 - 取值实参（如果有）。(8)
        // 可合并标识：
        // 0011 - 指令和附参。(3)
        // 0101 - 指令和关联数据。(5)
        // 0110 - 附参和关联数据。(6)
        // 0111 - 指令整体：指令、附参和关联数据。(7)
        // 1111 - 目标整体，含取值实参的值。(15)
        // 例：
        // MODEL<...> {
        //      DATA[32]{?} #4  提取前面DATA匹配目标的数据段。
        // }
        // #4 是 #[4] 的简写形式。
        // 注：
        // 提取的值会放入一个内部队列，作为MODEL最终的返回值。

116     $(1)        正则匹配取值。
        // 针对前一个正则匹配目标，取匹配值或子匹配式的值。
        // 附参：正则表达式或子表达式的取值序位。
        // 例：
        // MODEL<...> {
        //      TEXT{/[a-zA-Z]+/} $[0]  取目标字符串中匹配的单词
        // }
        // 例：
        // TEXT{/[a-zA-Z]+/} $0         同前。
        // TEXT{/Version-(\d+)/} $[1]   提取主版本号（首个子表达式匹配项）
        // TEXT{/Version-(\d+)/} $1     同上。简写形式
        // 注：
        // 上面示例中省略了上级封装指令 MODEL<>{}。
        // 指令 TEXT{/../} 详见后。

117     ?           指令通配。
        // 目标指令可为任意指令（含附参和关联数据）。
        // 例：
        // ?    当前目标位置为任意一个指令。

118     ?(1)        指令局部通配。
        // 用跟随指令来和目标作比较，附参指定了通配的部分。
        // 附参：位置标识。
        // 0000 0001 - 关联数据任意。(1)
        // 1000 0000 - 第1个附参任意，其它附参严格匹配。(128)
        // 0100 0000 - 第2个附参任意，其它附参严格匹配。(64)
        // 0010 0000 - 第3个附参任意，其它附参严格匹配。(32)
        // 0001 0000 - 第4个附参任意，其它附参严格匹配。(16)
        // 0000 1000 - 第5个附参任意，其它附参严格匹配。(8)
        // 0000 0100 - 第6个附参任意，其它附参严格匹配。(4)
        // 0000 0010 - 第7个附参任意，其它附参严格匹配。(2)
        // 注：
        // 最多支持7个附参的通配标记，各个通配位可任意同时设置。
        //
        // 例：
        // ?[1] DATA[32]  跟随指令的关联数据任意（但必须为32字节长）。
        // ?1 DATA[32]    同上。
        // DATA[32]{?}    同上。更友好的表达，由解析器智能分辨。
        // TEXT[300]{?}   匹配300字节长任意文本。将被解析为 TEXT{}(2) 指令。
        // 注意：
        // DATA[?]{?}     不确定，依赖于解析器生成的指令：DATA{}(1) 或 DATA{}(2)
        // !Bytes         替代上面的需求，匹配任意字节序列（见后）。
        //
        // 例：
        // ?64 PEEKS[-3]  首个附参确定，第二个附参任意。即下标位置确定，引用数量任意。
        // PEEKS[-3, ?]   同上，含义更清晰。
        // (?)            目标是一个运算表达式，同：!CalExp
        // ({10} + (?))   目标是表达式内的一个优先级分组指令。
        //
        // 例：
        // IF[60]{?}    匹配if指令，关联的语句块长60字节，内容不限。
        // IF[?]{?}     匹配一个if指令，长度和内容都任意。
        // IF[?]{...}   匹配一个if指令，内容等待进阶匹配。
        // IF{...}      同上。简化写法。
        //
        // 例：
        // @ ?1 DATA[32]    匹配实参取值，任意32字节序列。
        // @ DATA[32]{?}    同上。
        // @ !Bytes         匹配两个DATA{}指令取值。
        // & POP        匹配 &POP 复合指令，空格是可选的。
        // &[?]         匹配任意取局部域成员指令。
        // ?128 &       同上。

119     !{TYPE}(1)  类型匹配。
        // 目标为特定类型的值指令。
        // 附参：类型名。
        // - Bool   布尔值
        // - Int    整数（7个）
        // - BigInt 大整数
        // - Float  浮点数（2个）
        // - Bytes  字节序列（2个）
        // - String 字符串（2个）
        // - RegExp 正则表达式（/.../）
        // - Date   日期/时间（TIME{}）
        // - Script 脚本代码（CODE{}）
        // - CalExp 运算表达式（(...)）
        // 例：
        // !{Bool}  目标必须是布尔类型（TRUE|FALSE）。
        // !Bool    同上，可省略花括号。
        // !Bytes   匹配两个 DATA{} 指令。
        // !String  匹配两个 TEXT{} 指令。
        // !Script  匹配 CODE{} 指令。
        // !Int     匹配任意整数。
        // !Float   匹配任意浮点数。
        // !CalExp  目标是一个运算表达式：(...)。

120     !{}(~,~)    整数值范围匹配。
        // 限定目标值在设定的范围之内，包括边界值。
        // 附参1：下限值，变长整数。
        // 附参2：上限值，变长整数。
        // 例：
        // !{0, 1024} 限定目标值：0 ≦ n ≦ 1024。
        // !{0, 127}  目标应当是一个 {}(1) 整数指令（不要求）。
        // 注：
        // 整数有多个指令表达，范围匹配不要求目标具体是哪个指令。
        // 本指令暂不支持大整数（BigInt）范围。

121     !{}(8,8)    浮点数值范围匹配。
        // 限定目标值在设定的范围之内，包括边界值。
        // 附参1：下限值，8字节表达。
        // 附参2：上限值，8字节表达。
        // 例：
        // !{0, 1.0}  限定目标值大于等于0，小于等于1.0。
        // 注：
        // 两个边界值必须至少有一个是浮点数表示，否则会识别为整数范围。

122     TEXT{/../}(1)   正则模式匹配，适用String类型。
        // 目标需为TEXT{}指令，双斜线包围待用的正则表达式。
        // 附参：匹配表达式的长度。
        // 例：
        //      TEXT{/Zip:[0-9]+/}
        // 目标TEXT{}的内容是否匹配这里的正则表达式。
        // 注：
        // 正则表达式语法请参考 https://golang.org/s/re2syntax

123     ...         任意指令段匹配。
        // 匹配任意目标指令序列，包括各指令的附参和关联数据。
        // 通配只限于当前层级（同域），子语句块作为一个整体对待。
        // 贪婪匹配模式。
        // 例：
        // 目标脚本：
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      @TOP PRINT              // 1
        //      IF{
        //          @POP PRINT
        //      }
        //      TRUE
        //      IF{
        //          TEXT{Hello in IF}   // 2
        //          @TOP PRINT          // A
        //      }
        //      TEXT{done!}
        //      @TOP PRINT              // B
        //      LOPS[]
        // 模型：
        // MODEL<>{
        //      SYS_TIME{Stamp}         // 换行没问题
        //      {<expireTime>} GT
        //      ...                     // 1
        //      IF{
        //          ...                 // 2
        //          @TOP PRINT          // A
        //      }
        //      TEXT{done!}
        //      @TOP PRINT              // B
        //      LOPS[]                  // 终点完整匹配
        // }
        // 1.
        // 第一个...适配「@TOP PRINT IF{...} TRUE」。
        // 2.
        // 第二个...适配「TEXT{Hello in IF}」，到A为止，不会跨层到B。
        // 注：非贪婪和同域同时约束。
        //
        // 模型：
        // MODEL<>{
        //      SYS_TIME{Stamp}
        //      {<expireTime>} GT
        //      ... IF{?} ...       // IF匹配第二个IF（贪婪）
        // }
        // 第二个...是必须的，匹配到脚本结束，否则整个匹配失败（完整匹配要求）。
        //
        // 参考：
        // 如果将嵌套构造为树结构，是一个广度优先的查询。
        // 但不同域内的模式取值（#）需要保持浏览顺序（深度优先）。

124-125 （保留未用）
```


#### 附：模式匹配包含的内容

1. **位置匹配**：滤除掉可以忽略的指令后，位置一一对应。即：位置记数不包含可忽略指令。
2. **指令匹配**：指令相同即为匹配。如果指令为值指令，则也隐含了类型匹配逻辑。
3. **附参匹配**：在指令匹配的前提下，附参参与匹配。
4. **数据匹配**：在指令匹配的前提下，指令关联的数据也参与匹配。
5. **正则匹配**：`TEXT{/../}` 可对文本目标进行正则匹配。
6. **范围限定**：整数和浮点数的范围匹配，内部的细分类型被忽略。
7. **类型匹配**：对目标的数据类型执行匹配，值任意。

> **注：**
> 流程类指令（`IF{}`、`SWITCH{}` 等）在有子内容匹配时，附参会被忽略。


### 12. 环境指令

脚本的运行处在一个逐层嵌套的环境里：`系统环境 > 交易全局 > 校验域 > 脚本域 > 局部域`，其中前者是后者的父级域。

1. **系统环境**。包含整个区块链系统的一些基本信息。通常为只读。
2. **交易全局**。覆盖整个交易，可触及其它兄弟输出和当前输入自身。
3. **校验域**。  当前输出脚本的校验运行，包含 `GOTO` 跳转到的远端脚本。
4. **脚本域**。  当前脚本范围，包含 `JUMP` 嵌入的子脚本。
5. **局部域**。  当前脚本顶层的存储区、以及嵌套语法块的子域。都是私有逻辑，无法互访。


值区间：`[126-133]`，8个。

```go
指令值  指令字      说明
-----------------------------------------------------------
126     EVN{}(1)    交易域环境取值。
        // 当脚本作为输入项运行时构造的环境，针对当前使用它的交易。
        // 附参：目标名称的标识值。
        // 返回值：目标成员值。
        // 书写时可以使用标准的名称，但需放在花括号内。
        // 成员：
        // - Height      理想块高度
        // - RealHeight  交易打包进的实际区块的高度
        // - TxID        交易ID
        // - Timestamp   交易时间戳
        // - GoodTime    理想块时间戳
        // - FromHeight  源交易所在理想块高度
        // - FromTxID    源交易ID
        // - InTotal     输入项总数
        // - InAmount    输入总金额
        // - OutTotal    输出项总数
        // - OutAmount   输出总金额
        // - GOTOFrom    GOTO跳转来源（管理者交易）
        // - JUMPFrom    JUMP跳转来源
        // - FromSource  跳转来源前段指令序列（截止跳转位置，不含跳转指令本身）
        // - GotoCount   当前跳转计数（管理者交易）
        // 例：
        // EVN{RealHeight} 获取交易所在区块真实高度。

127     OUT{}(1,1)  当前交易的某个输出项取值。
        // 在脚本作为输入项花费时，针对当前交易的输出项集。
        // 可用于输入项限定花费的目标。
        // 附参1：目标输出项的序位（起始值0）。
        // 附参2：输出项中的成员的标识。
        // 返回值：目标成员值。
        // 成员：
        // - Amount      币金数量
        // - Receiver    接收者
        // - Description 凭信描述
        // - Count       凭信转移计数
        // - Title       证据标题
        // - Content     证据内容
        // - Attachment  附件ID
        // - Script      输出脚本自身
        // - Datum       输出条目的完整数据序列
        // - Index       在输出集中的序位
        // 例：
        // OUT[0]{Amount} 取交易中首个输出项的币金数量。
        // 注记：
        // 输出项序位仅用1字节表示，虽然一笔交易中的输出项可以更多。
        // 如果需要支持更大输出序位定位，可采用附参替代技术。

128     IN{}        当前输入项运行时信息取值。
        // 大部分为源输出项自身的信息。
        // 返回值：目标成员值。
        // 成员：
        // - Amount      币金数量
        // - Receiver    接收者
        // - Description 凭信描述
        // - Count       凭信转移计数
        // - Title       证据标题
        // - Content     证据内容
        // - Attachment  附件ID
        // - Script      输入脚本自身
        // - Timestamp   源交易的创建时间戳
        // - Signsum     合法签名的数量
        // 注：
        // 当前交易的输入项实际上是上一笔交易的输出项。

129     INOUT{}(1,1) 输入项的兄弟输出项取值。
        // 即输入项所在源交易的兄弟输出项取值，可建立不同输出之间的关联。
        // 附参1:目标输出项的序位（起始值0）。
        // 附参2:输出项中目标成员的标识值。
        // 返回值：目标成员值。
        // 成员：参考前 OUT 指令。

130     MULSIG(1)   多重签名序位确认。
        // 目标序位的签名合法时返回TRUE，否则返回FALSE。
        // 附参：目标序位。即签名者序号，从0开始。
        // 返回值：布尔值。
        // 注：指令属于校验域范围。
        // 例：
        // MULSIG[2]  确认多重签名哈希列表中第3序位者参与签名。
        // 另：
        // 也可用于模拟2/3多重签名验证：
        // MULSIG[0] MULSIG[1] MULSIG[2] @POPS[3] SOME[2] PASS

131     VAR(1)      全局变量取值。
        // 附参：目标变量位置下标。
        // 与局部域不同，此为变量逻辑，可被定位覆盖赋值，
        // 因此为 uint8 类型，最多支持256个变量。
        // 返回值：预存在目标置位的值。任意类型，单值。
        // 例：
        // @VAR[0] 取全局变量里首个变量值到当前实参空间。
        // VAR[10] 取全局变量里第11号位置的值入栈。
        // 注：
        // 本指令属于脚本域（不跨GOTO跳转脚本）。
        // JUMP指令跳转的脚本共享同样的脚本域空间，因此会相互影响。

132     SETVAR(1)   全局变量赋值。
        // 对脚本域的全局变量赋值，变量定位采用位置下标，可覆盖。
        // 附参：变量位置下标。
        // 实参：任意类型，单值。
        // 返回值：无。
        // 例：
        // {123} SETVAR[1]   将栈顶的值存入全局变量空间第2个位置。
        // {1.5} SETVAR[255] 将浮点数1.5存入全局变量空间最后一个位置。
        // 注：
        // 本指令的赋值空间仅由 VAR 指令读取。

133     （保留未用）
```


### 13. 工具指令

主要包含一些基础性并常用的功能性指令。

值区间：`[134-153]`，20个。

```go
指令值  指令字      说明
-----------------------------------------------------------
134     EVAL        子脚本执行。
        // 实参：脚本指令值序列。
        // 返回值：无。
        // 外部嵌入脚本的方式：
        // - 解锁脚本。公共逻辑，任何节点都需要执行。
        // - 缓存区导入。私有逻辑，需要部署的节点自我处理。
        // - 管理者交易。JUMP带入，公共逻辑。
        // 限制：
        // 1. 实参长度 < 256字节。
        // 2. 实参内禁止EVAL（二次使用）。
        // 提示：
        // 高消耗的脚本可能导致不受欢迎而被拉入黑名单。

135     SIZE        集合大小。
        // 实参：一个集合，可用len()计算的对象。
        // 返回值：一个整数。

136-139 （系统保留）

140     PICK(1)     条目拣取（多选一）。
        // 获取数据集合中的单个成员。
        // 附参：成员位置下标。int8类型，支持负数从末尾算起。
        // 实参：目标集（切片或数组）。
        // 可用于核实事先罗列的清单中的某项条目。
        // 返回值：目标成员值，单值。
        // 例：
        //      SLICE[3] PEEK[0] ~PICK EQUAL PASS
        // - 取栈顶3项打包为一个集合入栈。
        // - 取栈底成员值（可能由解锁实参传入）入栈。
        // - 附参替代获取位置下标（即 PEEK[0] 的值），提取集合中目标成员值入栈。
        // - 比较此时的栈顶2项是否相等（3个成员已弹出，最新入栈为拣取值）。
        // - 相等则验证通过。

141     PICKS(1,1)  拣取多个条目（多选多）。
        // 获取数据集合中某区段成员集。
        // 附参1：起始位置下标。int8类型，支持负数从末尾算起。
        // 附参2：获取条目数量。uint8类型。
        // 实参： 目标集（切片或数组）。
        // 返回值：一个切片，单值。

142     RANGE(1,1)  创建数值序列。
        // 一个以步进值为递增的连续值序列，包含起始值本身。
        // 附参1：起始值。
        // 附参2：序列长度（单元个数）。
        // 实参： 步进值，可选（默认1）。
        // 返回值：一个切片，单值。
        // 例：
        // @{2} RANGE[10, 5]  生成 [10, 12, 14, 16, 18]。
        // RANGE[10, 5]  生成 [10, 11, 12, 13, 14]，无实参，默认1。

143-153 (保留未用)
```


### 14. 系统指令

执行系统级功能的指令。

值区间：`[154-159]`，6个。

```go
指令值  指令字          说明
-----------------------------------------------------------
154     SYS_ENV{}(1)    获取系统级环境值。
        // 附参：目标名称的标识值。
        // 项目：
        // - BlockHeight 区块链当前最新高度
        // - BlockTime   当前最新区块创建的时间戳
        // - LimitStack  栈高度上限（256）
        // - LimitScope  局部变量域上限（128）
        // - ……
        // 例：
        // SYS_ENV{BlockHeight} 获取区块链当前最新高度。

155     SYS_TIME{}(1)   取全局时间对象的属性值。
        // 全局时间对象是客户端真实的当前时间，只读。
        // 附参：目标属性的标识值。
        // 每一个属性被规划为固定的序号位置，但也包含标准的命名。
        // 如果采用字符串名称，应当书写在花括号内。
        // 属性：
        // - Stamp      当前时间戳（毫秒）
        // - Year       年数（4位）
        // - Month      月次/年（1-12）
        // - YearDay    日次/年（1-365|366）
        // - Day        日次/月（1-31）
        // - WeekDay    日次/周（0-6）
        // - Hour       时数/日（0-23）
        // - Minute     分钟数/时（0-59）
        // - Second     秒数/分钟（0-59）
        // 例：
        // SYS_TIME{Stamp} 获取当前系统时间戳值入栈。
        // SYS_TIME[0] 同上（假设Stamp的序号为0）。

156     SYS_AWARD       兑奖验算。
        // 检查当前交易所在区块之后240个区块的兑奖槽，计算奖金兑现。
        // 规则：
        //      确认数   兑现比例
        //      ----------------
        //      1        20%
        //      2        40%
        //      3        60%
        //      4        80%
        //      5        100%
        // 说明：
        // 因为是统计之后的区块的兑奖确认数，所以奖励必须超过一天才能兑现。
        // 当前铸造者需要分析前面240个区块的兑奖槽并计算-241号区块的奖金截留。
        // 用户能够取走的奖金和将要被截留的部分是各自计算，但应互为契合。
        //
        // 注记：
        // 兑奖指令仅适用Coinbase交易，可能是被强制执行而非在输出脚本中书写。

157-159 （保留未用）
```


### 15.函数指令

值区间：`[160-199]`，40个。


#### 基础函数集

定义一些常用的函数。注意指令的书写是按普通函数定义的方式，实参要求书写在了括号包围的参数序列里，这更直观。

```go
指令值  函数名（参数序列） => 返回值类型
-----------------------------------------------------------
160     FN_HASH256 (data Bytes) => Bytes
        // 实参：任意字节序列。
        // 哈希计算，可用于哈希屏障保护。
        // 返回值：32字节长。

161     FN_BASE32A (data Bytes) => String
        // 实参：任意字节序列。
        // 定制版Base32编码，后缀A表示Alphabet，采用纯字母序列。
        // 详见：libs/b32addr/b32addr.go#EncodeAddr

162     FN_HASH160 (data Bytes) => Bytes
        // 实参：任意字节序列。
        // 哈希计算，主要用于公钥的哈希计算。
        // 返回值：20字节长。
        // 注：
        // 字节形式的公钥哈希地址简称为公钥地址。

163     FN_ADDRESS (pbhash Bytes) => String
        // 实参：公钥哈希地址。
        // 将字节格式的公钥哈希地址编码为文本地址（代替Base58），通常前置专有标识。
        // 注意：
        // 文本形式的公钥地址与字节格式的公钥地址是一样的，
        // 文本形式主要用于书写阅读，交易中则实为字节格式的哈希序列。
        //
        // 编码：
        // 1. 对公钥地址再执行一次哈希运算，取末尾4字节为校验码。
        // 2. 在公钥地址之后附上前面的校验码，编码为 Base32 形式，即为公钥的文本地址。
        // 校验：
        // 1. 将公钥的文本地址解码为字节序列。
        // 2. 截取该字节序列的最后4字节为校验码，前段为公钥地址。
        // 3. 对前段的公钥地址执行一次哈希，取末尾4字节与校验码对比，相同则地址合法。
        //
        // Base32编码：
        // 微调标准版Base32：采用26个大写字母（A-Z）和6个数字（456789）。
        //
        // 前缀字符：
        // - 1  普通账户地址，单签名。
        // - 2  1/2签名账户地址。
        // - 3  2/3签名账户地址专属。
        // - 0  定制多重签名账户地址（非2和3类型）。

164     FN_CHECKSIG (sig, pubkey Bytes) => Bool
        // 单签名验证（签名，公钥）

165     FN_MCHECKSIG (sig Bytes, n, t byte, pubkeys, restpkhs []Bytes) => Bool
        // 多重签名验证（签名, n/t配比, 公钥集, 剩余公钥地址集）

166-196 （待定）

197     FN_PRINTF (fmt, val, ...) => nil
        // 格式化打印（格式化串，实参1，实参2，...），同 go:fmt.Printf。
        // 不定参数指令。
```


#### 扩展函数集

两个扩展类指令引入更多可能需要的函数。

```go
指令值  指令字          说明
-----------------------------------------------------------
198     FN_A(1)         一级扩展（1字节空间）。
        // 1字节的附参可包含256个扩展函数。

199     FN_B(2)         二级扩展（2字节空间）。
        // 2字节的附参可包含64k个扩展函数。
```


### 16.模块指令

模块的成员以标准的名称书写在花括号内，附参通常仅为1个字节，用于索引成员函数。

通常，模块如果需要创建一个表示自身的对象，应由首个成员 `Create` 实施。作为约定，如果其它成员函数需要使用该对象，应作为首个参数传入。

值区间：`[200-247]`，48个。

```go
指令值  指令字          说明
-----------------------------------------------------------
200-209 （待定）

210     MO_RE{}(1)      正则表达式模块。
        // 处理正则表达式对象，对象作为首个参数传入。
        // 可由 /.../ 指令创建，或由 REGEXP 指令转换而来。
        // 方法：
        // - （待定）

211     MO_DATE{}(1)    日期对象模块。
        // 处理日期/时间对象，对象作为首个参数传入。
        // 可由 TIME{} 指令创建，或由 DATE 指令转换而来。
        // 方法：
        // - （待定）

212     MO_MATH{}(1)    数学运算模块。
        // 例：
        // MO_MATH{Abs} 计算实参的绝对值。
        // 成员：
        // - Abs    绝对值：|-4| => 4
        // - Pow    幂乘值：x**y
        // ...

213     MO_CRYPT{}(1)   加密运算模块。
        // 对称加密：
        //
        // 非对称加密：
        //

214-246 （待定）

247     MO_X(1)         标准扩展引用。
        // 1字节支持256个扩展模块。
        // 注：
        // 如需更多模块支持，建议使用扩展区指令（EX_BASE2）。
```


### 扩展指令区

最后的8个指令空间用于扩展指令区（`[11111xxx]`）。

指令的扩展籍由附参实现，主要包含了2个预置的引用指令：附参定位了扩展的指令本身，而该扩展指令是一个完整的逻辑，可以包含其自身的附参。这种扩展方式实际上是一种 **附参递进** 的逻辑，理论上可以无限递进深层嵌套（类似XML树）。

值区间：`[248-255]`，8个。

```go
指令值  指令字          说明
-----------------------------------------------------------
248     EX_BASE1(1)     基础扩展引用（1字节空间）。
        // 1字节的附参可包含256个扩展指令。

249     EX_BASE2(2)     基础扩展引用（2字节空间）。
        // 2字节的附参可包含64k个扩展指令。

250-252 （待定）

253     EX_PRIV1(1)     私有扩展引用（1字节空间）。
        // 私有范畴，公共节点简单忽略（不执行）。
        // 通常由有特定需求的应用使用。
        // 注：
        // 如果在模式语句块内使用，则遵循正常的模式匹配逻辑，
        // 这不会导致指令运行。

254     EX_PRIV2(2)     私有扩展引用（2字节空间）。
        // 同上。较大扩展空间容量（64k）。

255     （系统保留）
```


-------------------------------------------------------------------------------

上一篇：[脚本系统设计](5.脚本系统设计.md)<br>
下一篇：[附1：组队校验](附1.组队校验.md)<br>
